Report: Strategies for Consuming the GitHub API in a Blazor Application
An analysis of the GitHub REST API (https://api.github.com) reveals several key considerations for integration into a Blazor application: rate limiting, caching, and security.

Rate Limits: The GitHub API imposes strict rate limits which differ for unauthenticated and authenticated requests. Unauthenticated requests are limited to 60 requests per hour, scoped to the user's IP address. This is insufficient for any serious application. Authenticated requests using an OAuth or Personal Access Token significantly increase this limit to 5,000 requests per hour. To handle this in Blazor, all API calls should be authenticated. Furthermore, the application should inspect the HTTP response headers returned by the API, specifically X-RateLimit-Remaining and X-RateLimit-Reset. If the remaining count is low, the application can proactively disable features or inform the user to wait until the reset time, which is provided as a UTC epoch timestamp in the X-RateLimit-Reset header.

Caching Policies: The API heavily utilizes HTTP caching via ETags and the Last-Modified header. When fetching data, the API returns an ETag header. For subsequent requests for the same resource, the Blazor application should include an If-None-Match header with the stored ETag value. If the data has not changed, the GitHub API will respond with a 304 Not Modified status, saving bandwidth and counting against a lower rate limit. This can be implemented in a Blazor service by storing ETags in memory (e.g., in a dictionary) alongside the cached data. When a request is made, the service first presents the cached data, then makes a conditional background request with the ETag to check for updates, refreshing the UI only if new data is received.

Security Features: The API requires authentication for most non-trivial use cases and all write operations. The recommended approach is OAuth 2.0 for user-facing applications. For a Blazor client-side application (WebAssembly), the secure and standard approach is to handle the OAuth flow and store the resulting access token. This token must then be included in the Authorization header of every API call (e.g., Authorization: Bearer YOUR_TOKEN). To manage credentials securely in Blazor WASM, the token should not be stored in localStorage. Instead, it should be held in memory within a scoped service for the user's session. For server-side Blazor, the token can be stored more securely in a user-specific, encrypted session state managed by the server.